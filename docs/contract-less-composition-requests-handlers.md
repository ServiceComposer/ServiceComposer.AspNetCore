# Contract-less composition requests handlers

_Available starting version 4.2.0-beta.1_

Contract-less composition handlers allow to write composition handlers using a syntax like the following:

<!-- snippet: contract-less-handler-sample -->
<a id='snippet-contract-less-handler-sample'></a>
```cs
[CompositionHandler]
class SampleCompositionHandler
{
    [HttpGet("/sample/{id}")]
    public Task SampleMethod(int id, [FromQuery(Name = "c")]string aValue, [FromBody]ComplexType ct)
    {
        return Task.CompletedTask;
    }
}
```
<sup><a href='/src/Snippets/Contractless.CompositionHandlers/SampleCompositionHandler.cs#L7-L17' title='Snippet source file'>snippet source</a> | <a href='#snippet-contract-less-handler-sample' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Compared to what is available today, when using classes that implement `ICompositionRequestsHandler`, contract-less composition request handlers allow grouping handlers belonging to the same logical context, rather than being forced to artificially split them into multiple classes due to the need to implement an interface.

The syntax is nonetheless similar to ASP.NET controller actions. At compilation time, ServiceComposer identifies contract-less composition request handlers by the presence of the `[CompositionHandler]` attribute on the class:

- Contract-less composition request handlers must be decorated with the `[CompositionHandler]` attribute.
- The contract-less composition request handler class can contain one or more methods; these methods must:
  - Be either `public` or `internal`
  - Return a `Task`
  - Be decorated with one, and only one, `Http*` attribute (known limitation for now)
  - Can use the standard ASP.NET `From*` attributes to control model binding, including `[FromServices]` to resolve dependencies from the DI container

### Known limitations

- Different from classes implementing `ICompositionRequestsHandler`, contract-less composition handlers, at the moment, support only one `Http*` attribute per method;

## Source generation

Given a class like the above one, a C# source generator will create a class like the following:

```csharp
// <auto-generated/>
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.ModelBinding;
using ServiceComposer.AspNetCore;
using System;
using System.ComponentModel;
using System.Threading.Tasks;

#pragma warning disable SC0001
namespace YourNamespace.Generated
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    class SampleCompositionHandler_SampleMethod_int_id_string_aValue_ComplexType_ct(SampleCompositionHandler userHandler)
         : ICompositionRequestsHandler
    {
        [HttpGetAttribute("/sample/{id}")]
        [BindFromRoute<Int32>("id")]
        [BindFromQuery<String>("c")]
        [BindFromBody<ComplexType>()]
        public Task Handle(HttpRequest request)
        {
            var ctx = HttpRequestExtensions.GetCompositionContext(request);
            var arguments = ctx.GetArguments(this);
            var p0_id = ModelBindingArgumentExtensions.Argument<Int32>(arguments, "id", BindingSource.Path);
            var p1_c = ModelBindingArgumentExtensions.Argument<String>(arguments, "c", BindingSource.Query);
            var p2_ct = ModelBindingArgumentExtensions.Argument<ComplexType>(arguments, BindingSource.Body);

            return userHandler.SampleMethod(p0_id, p1_c, p2_ct);
        }
    }
}
#pragma warning restore SC0001
```

Both classes will be registered in DI, allowing the injection of dependencies into the user contract-less composition handler. If the user contract-less composition handler defines more than one method matching the above requirements, one class for each method will be generated. The generated class name will guarantee uniqueness.

### Services injection via `[FromServices]`

Parameters decorated with `[FromServices]` are resolved from the DI container at request time. For example:

```csharp
[CompositionHandler]
class SampleCompositionHandler
{
    [HttpGet("/sample/{id}")]
    public Task SampleMethod(int id, [FromServices] IMyService myService)
    {
        return Task.CompletedTask;
    }
}
```

The source generator will emit a `[BindFromServices<T>]` attribute for the parameter and resolve it via the DI container when the request is handled:

```csharp
[HttpGetAttribute("/sample/{id}")]
[BindFromRoute<Int32>("id")]
[BindFromServices<IMyService>("myService")]
public Task Handle(HttpRequest request)
{
    var ctx = HttpRequestExtensions.GetCompositionContext(request);
    var arguments = ctx.GetArguments(this);
    var p0_id = ModelBindingArgumentExtensions.Argument<Int32>(arguments, "id", BindingSource.Path);
    var p1_myService = ModelBindingArgumentExtensions.Argument<IMyService>(arguments, "myService", BindingSource.Services);

    return userHandler.SampleMethod(p0_id, p1_myService);
}
```
